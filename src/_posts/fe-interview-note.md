---
title: 关于前端面试的一些思考和总结
date: 2019-08-21
category: 个人提升
tags: 
	- 前端面试
vssue-title: fe-interview-note
---
> 作为一个五年开发经验的前端老菜鸟，在面试这方面的经验并不是很丰富，虽然五年换了四份工作，但面试的次数竟屈指可数。

## 一、对于 MVVM 的理解
**MVVM** 是 **Model**（数据层）- **View**（视图层）- **ViewModel**（视图逻辑层）的缩写。

**MVVM** 模型主要是利用数据的双向绑定原理，使得 Model 中的数据发生变化时，便会引起 ViewModel 中相应的变化，ViewModel 的变化又会引起 View 的更新。**MVVM** 模式简化了视图与业务的依赖关系，解决了数据频繁更新的问题。

## 二、谈谈对 Vue 的理解
Vue 是一个渐进式的单页应用程序(SPA)开发框架，

主要可以从以下几个方面进行思考：
1. 数据代理
2. 双向绑定
3. 模板解析
4. VNode的Diff算法

## 三、Vue 的数据双向绑定
Vue.js 是采用**数据劫持**结合 **发布者-订阅者模式**的方式，通过`Object.defineProperty()`来劫持各个属性的`setter/getter`，在数据变动时发布消息给订阅者，触发相应的监听回调。

`Object.defineProperty` 是 ES5 中一个无法 shim的特性，这便是 Vue 不支持 IE8 以下版本浏览器的原因。

参考官网的图片如下：
![](https://cn.vuejs.org/images/data.png)

双向绑定的优点：数据之间是想通的，将数据的变更操作隐藏在框架内部，开发者无需关注具体的DOM操作即可更新视图，在表单交互较多的场景下，会简化大量与业务无关的代码。缺点是无法追踪局部状态的变化，增加了 debug 难度。

## 四、Vue 如何进行数组监听
原因：由于 `Object.defineProperty` 不能监听数组变化，所以在 Vue 是这样做的：
1. 从数组的原型中新建一个 `Object.create(arrayProto)` 对象，通过修改此原型可以保证原生数组方法不被污染；
2. 如果当前浏览器支持 `__proto__`属性，则直接覆盖该属性，使数组对象具有了重写后的数组方法，如果不支持，则必须通过遍历 dep中所有需要重写的数组方法；

在保证不污染不覆盖数组原生方法的前提下添加监听，主要进行了两个操作，第一是通知所有注册的观察者进行响应式处理，第二是如果是添加成员的操作，需要对新成员进行 `Observer`。

## 五、Vue 的模板解析是怎样的流程
1. Vue 通过使用 `createCompiler` 创建一个编译器 `compile`，`compile` 会将传入的 `template` 转换成对应的 AST（抽象语法树）；
2. AST 的最外层是根节点 `div`，还有很多其他属性: `static`、`staticClass`、`if`、`children`、`parent`...；
3. 通过 `render` 函数返回的 VNode 节点，在 `_update` 的时候，进行 `diff` 算法，得出差异后将这些差异渲染到真实 DOM 上。
AST 会经过 `generate` 得到 `render`函数，`render` 的返回值是虚拟DOM节点 VNode。

## 六、Vue 中 VNode 如何进行 Diff

通过比较同层的树节点，而非对树进行逐层搜索遍历的方式，所以时间复杂度只有 O(n)，是一种相当高效的算法。

## 七、Vue 中的 data 为何不能是一个对象
在定义一个组件时，如果该组件被用来创建多个实例， 那么 `data` 不能是一个纯粹的对象，因为所有的实例将共享引用同一个数据对象。此时，`data` 必须声明为返回一个初始化数据的函数，这样在每次创建一个新实例后，我们就能够调用 	`data` 函数，从而返回一个全新的数据对象。

## 八、Vue 中的组件通信

1. 父子组件传值: `props`（父组件向子组件传值）和 `emit`（子组件通过调用父组件的 emit 方法来传值）;
2. 跨组件传值：`eventBus`，各组件通过用引入一个公用的状态文件来进行组件间的通信。通常在一个应用中，`eventBus`会形成一种网状的结构，与 Vue 的组件的树结构差异较大，这种方式会造成状态管理混乱，而且在运维阶段会有一定的难度。

## 九、对 Vuex 的理解

1. 单向数据流
* state，驱动应用的数据源；
* view，以声明方式将 state 映射到视图；
* actions，相应在 view 上的用户输入导致的状态变化。

![单向数据流理念示意图](https://vuex.vuejs.org/flow.png)

单向数据流的好处是，可以追踪流动方向，方便追踪排查问题。缺点是维护起来不太方便，需要创建大量的对应的 action 来维护状态。

2. Vuex 是什么？

专为 Vue.js 开发的**前端状态管理模式**。主要有以下几个特点：
* 集中式管理所有组件的状态
* 以对应的规则来保证状态以一种可预测的方式发生变化。

可以想象为一个单页应用中，所有组件的数据都是保存在一个全局变量中，所有组件的状态都是从这个全部变量中获取或者修改的，`Vuex` 此时相当于一个管理员的身份，它规定了某种规则，要求各成员以这种规则来读写全局变量中的状态数据，这样做的好处时，可以随时跟踪操作进度，在各阶段都可以进行一些数据拦截、数据格式化、埋点上报等操作，更有利于追溯数据源，让状态的变化朝着一个可预测的方向发展。

## Vue 和 React 的比较

## 十、vue-cli 的原理和实现思路

## 十一、前端性能优化有哪些

## 十二、对 HTTP 2.0 的了解

## 十三、浏览器输入 url 到页面的展现，具体发生了些什么可以展开说下么

## 十四、JavaScript 面向对象的理解和感悟

## 十五、埋点的实现思路

## 十六、服务端渲染（SSR）的原理

## 十七、Node 中如何进行大文件的处理

Stream

## 十八、Koa 框架中中间件的处理

## 十九、Webpack 中 loader、plugin 的区别和实现思路

## 二十、对浏览器内核的理解

1. 浏览器内核主要分为两部分：渲染引擎和 JS引擎

渲染引擎负责取得网页的内容（HTML、XML、图像等）、整理讯息（加入CSS等），以及计算网页的显示方式，然后输出到显示器或者打印机上。浏览器的内核不同对于网页的语法解释也不同，所以渲染效果也不同。

JS引擎负责解析和执行JavaScript来实现网页的动态效果。后来由于JS引擎越来越独立，内核就倾向于只指渲染引擎。

2. 常见的浏览器内核：
	1. Triden内核：IE、MaxThon、TT、360、搜狗等；
	2. Webkit：Safari、Chrome等；
	3. Gecko：Firefox；
	4. Presto：Oprea7以上。

## 二十一、谈谈渐进增强和优雅降级

## 二十二、谈谈对前端工程化的理解

## 二十三、如何做好 CodeReview

## 二十四、多标签页之间的通信

## 二十五、浏览器数据流

## 二十六、谈谈对 Event-loop 的理解

## 二十七、对 ES6 的掌握程度

## 二十八、前端模块化的理解

## 二十九、重绘和重排的区别

## 三十、Webpack 的原理

## 三十一、Babel 的原理

## 三十二、常见的前端安全和策略

## 三十三、跨域的解决方案

## 三十四、如何做负载均衡

## 三十五、如何做移动端适配

## 如何做技术选型

## 对前后端分离的看法

## 如何看待前端工程师的未来