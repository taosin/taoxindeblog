---
title: 《你不知道的JavaScript（上卷）》之我读
date: 2019-07-29
tags:
	- Javascript
category: 个人提升
vssue-title: u-unkown-js-i
---

> JavaScript 既是一门充满吸引力，简单易用的语言，又是一门具有许多复杂微妙技术的语言，即使是经验丰富的 JavaScript 开发者，如果没有认真学习的话也无法真正理解它们。

> 这就是 JavaScript 的矛盾之处，也是这门语言的 阿克琉斯之踵。由于 JavaScript 不必理解就可以使用，因此通常来说很难真正理解语言本身，这就是我们面临的挑战。

<!-- more -->

## 第 1 章 作用域是什么

### 1.1 编译原理

传统编译语言在执行之前会经历三个步骤，统称为”**编译**“。

* 分词/词法分析（Tokenizing/Lexing）

这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元(token)。例如，`var a = 2;`，这段程序则会被分解成: `var`、`a`、`=`、`2`、`;`。

* 解析/语法分析（Parsing）

这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，即 “抽象语法树”(Abstract Syntax Tree, AST)。

* 代码生成

将 AST 转换成可执行代码的过程，这个过程与语言、目标平台等息息相关。以 `var a = 2;` 为例，简单来说就是有某种方法可以将它的 AST 转化为一组机器指令，用来创建一个叫做 `a` 的变量，并将一个值(这里为 `2` )存储在 `a` 中 。

*更多信息可以阅读《编译原理》一书。*

比起编译过程只有三个步骤的编译器，JavaScript 引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对性能进行优化，包括对冗余元素进行优化等等。

* JavaScript 的编译过程不是发生在构建之前，而是发生在代码执行前的几微妙（甚至更短！）的时间内。因此，JavaScript 引擎不会有大量的时间用来进行优化；
* 任何 JavaScript 代码片段在执行前都要进行编译。

### 1.2 理解作用域

### 1.2.1 演员表

* 引擎

从头到尾负责整个 JavaScript 程序的编译及执行过程。

* 编译器

负语法分析及代码生成等。

* 作用域

负责收集并维护所有生命的标识符（变量）组成的一些列查询，并实施一套非常严格的规则，确定当前执行的代码对这些变量的访问权限。

### 1.2.2 对话

在编译器将代码生成之前，会进行如下的处理：

1. 编译会会询问当前作用域的集合中是否已经存在同名的变量。如果是，编译器会忽略该声明，继续进行编译；否则会要求在当前作用域声明一个新的变量。
2. 编译器会为引擎生成运行时所需的用来处理 `a = 2` 的赋值操作。引擎运行时会首先询问当前作用域集合中是否存在该变量。如果是，引擎就会使用这个变量并赋值给它；否则会继续查找该变量，没有找到则会抛出一个异常！

**总结：** 变量的赋值操作会执行两个动作，首先编译器会在当前做用于中声明一个变量（如果之前没有声明过），然后再运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

### 1.2.3 编译器有话说

编译器在编译过程的第二步中生成了代码，引擎执行时，会通过查找变量 `a` 来判断它是否存在过，这个查找的过程是由作用域进行协助，但是引擎进行了怎么的查找呢？这个时候 **LHS**（赋值操作的目标是谁） 和 **RHS**（谁是赋值操作的源头） 出场了。

示例：

```js
console.log(a);
```

其中对 `a` 的引用是一个 RHS 引用，因为这里 `a` 并没有赋予任何值。

相比之下，例如：

```js
a = 2;
```

这里对 	`a` 的引用则是 LHS 引用。

下面的代码中，既有 LHS 也有 RHS 引用：

```js
function foo(a){
	console.log(a); //2
}

foo(2);
```

1. `foo(...)` 函数的调用需要对 `foo` 进行 RHS 引用；
2. `console.log(a)` 对 `a` 进行 RHS 引用，并将得到的值传给了 `console.log(...)`；
3. 另外代码中还存在隐式的 `a = 2` 操作，这个操作发生在 2 被当做参数传递给 `foo(...)` 函数时，2 会被分配给参数`a`，需要进行一次 LHS 引用。

### 1.2.4 引擎和作用域的对话

```js
function foo(a){
	console.log(2);  //2
}
foo(2);
```

让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。*引用书中的原文对话*

```html


```
